---
name: Issue Triage

"on":
  issues:
    types: [opened]

jobs:
  triage:
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Install dependencies
        run: npm install @anthropic-ai/sdk

      - name: Analyze issue
        uses: actions/github-script@v7
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }} # pragma: allowlist secret
          ISSUE_TITLE: ${{ context.payload.issue.title }}
          ISSUE_BODY: ${{ context.payload.issue.body }}
        with:
          script: |
            const Anthropic = require('@anthropic-ai/sdk');
            if (!process.env.ANTHROPIC_API_KEY) {
              console.log('No API key found, skipping triage.');
              return;
            }

            const client = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

            const title = process.env.ISSUE_TITLE;
            const body = process.env.ISSUE_BODY;
            const issueNumber = context.payload.issue.number;

            const prompt = `
            Analyze this GitHub issue and classify it:

            Title: ${title}
            Body: ${body}

            Return JSON with:
            {
              "type": "bug" | "feature" | "question" | "docs" | "other",
              "severity": "low" | "medium" | "high" | "critical",
              "area": "frontend" | "backend" | "api" | "docs" | "ci" | "other",
              "summary": "one-line summary",
              "hasReproSteps": boolean
            }
            `;

            try {
              const response = await client.messages.create({
                model: "claude-3-haiku-20240307",
                max_tokens: 1024,
                messages: [{
                  role: "user",
                  content: prompt
                }]
              });

              // Parse JSON from response (naive parsing, robust would be better)
              const text = response.content[0].text;
              const jsonMatch = text.match(/\{[\s\S]*\}/);
              if (!jsonMatch) {
                console.log('No JSON found in response');
                return;
              }

              let analysis;
              try {
                analysis = JSON.parse(jsonMatch[0]);
              } catch (e) {
                console.error('Failed to parse JSON:', e);
                return;
              }

              const labels = [];

              if (analysis.type === 'bug') {
                labels.push('bug');
                if (analysis.severity === 'high') labels.push('priority: high');
              } else if (analysis.type === 'feature') {
                labels.push('enhancement');
              } else if (analysis.type === 'question') {
                labels.push('question');
              }

              if (analysis.area) {
                labels.push(`area: ${analysis.area}`);
              }

              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: labels
                });
              }

              // Add initial response for bugs without repro steps
              if (analysis.type === 'bug' && !analysis.hasReproSteps) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: "Thanks for reporting this issue!\\n\\n" +
                        "To help us investigate, could you please provide:\\n" +
                        "- Steps to reproduce the issue\\n" +
                        "- Expected behavior\\n" +
                        "- Actual behavior\\n" +
                        "- Environment (OS, version, etc.)\\n\\n" +
                        "This will help us resolve your issue faster. üôè"
                });
              }
            } catch (error) {
              console.error('Error during triage:', error);
            }
